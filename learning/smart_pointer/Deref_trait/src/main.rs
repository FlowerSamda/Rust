// Deref 트레잇

// Deref 트레잇을 가지고 스마트 포인터를 평범한 참조자와 같이 취급하기

// Deref 트레잇을 구현하는 것은 역참조 연산자(*)의 동작을 커스터마이징하는 것을 허용
// 스마트 포인터가 평범한 참조자처럼 취급될 수 있는 방식으로 Deref를 구현
// -> 참조자에 대해 작동하는 코드를 작성하고, 이 코드를 또한 스마트 포인터에도 사용할 수 있음

/* Deref 트레잇이 없다면, 컴파일러는 오직 & 참조자들만 역참조 가능
** Deref 트레잇은 & 참조자 값을 반환, 그리고 *로 역참조
** -> 결국, Deref 트레잇이 있든 없든 간에 동일한 방식으로 되도록 해서, 생각하기 편하고, deref 트레잇 호출시 소유권도 안넘어감!
*/



fn main() {

    // *와 함께 포인터를 따라가서 값을 얻기
    // 보통의 참조자는 포인터 타입이며, 이는 다른 어딘가에 저장된 값을 가리키는 화살표로 생각하는 것임
    let x = 5;
    let y = &x;

    assert_eq!(5, x);
    assert_eq!(5, *y);  // 참조자를 따라가서, 가리키고 있는 값을 얻는 것 -> 역참조
    // assert_eq!(5, y);  y는 참조자인데, 숫자와 숫자에 대한 참조자를 비교하는 건 서로 다른타입이라 불가능!

    // Box<T>를 참조자처럼 사용하기
    let y = Box::new(x);  // y는 x를 가리키는 박스
    assert_eq!(5, *y);    // y를 역참조 (Box에 Deref가 구현되어 있기 때문!)

    // 나만의 스마트 포인터 정의하기

    struct MyBox<T>(T);         // 튜플 구조체 (T)

    impl<T> MyBox<T> {
        fn new(x: T) -> MyBox<T> {
            MyBox(x)
        }
    }
    use std::ops::Deref;        // Deref 트레잇이 없다면, 컴파일러는 오직 &참조자들만 역참조 가능!
    impl<T> Deref for MyBox<T> {
        type Target=T;          // Deref 트레잇이 사용할 연관 타입을 정의

        fn deref(&self) -> &T {
            &self.0             // (T)의 0번 인덱스 !참조! 값을 줌! (왜냐하면 역참조 해야하니까!)
        }
    }

    
    let x = 5;
    let y = MyBox::new(x);
    
    assert_eq!(5, x);
    assert_eq!(5, *y);
    

}
