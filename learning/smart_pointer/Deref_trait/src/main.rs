// Deref 트레잇

// Deref 트레잇을 가지고 스마트 포인터를 평범한 참조자와 같이 취급하기

// Deref 트레잇을 구현하는 것은 역참조 연산자(*)의 동작을 커스터마이징하는 것을 허용
// 스마트 포인터가 평범한 참조자처럼 취급될 수 있는 방식으로 Deref를 구현
// -> 참조자에 대해 작동하는 코드를 작성하고, 이 코드를 또한 스마트 포인터에도 사용할 수 있음

/* Deref 트레잇이 없다면, 컴파일러는 오직 & 참조자들만 역참조 가능
** Deref 트레잇은 & 참조자 값을 반환, 그리고 *로 역참조
** -> 결국, Deref 트레잇이 있든 없든 간에 동일한 방식으로 되도록 해서, 생각하기 편하고, deref 트레잇 호출시 소유권도 안넘어감!
*/

//---------------------------------------------------------------------------------------------------------------------------

// 함수와 메소드를 이용한 !암묵적 역참조 강제!

// 역참조 강제(deref coercion)는 러스트가 함수 및 메소드의 인자에 수행하는 편의성 기능
// -> 본래의 타입으로부터 바꿀 수 있는 타입의 참조자로 바꿔줌

/* 역참조 강제는 우리가 특정 타입의 값에 대한 참조자를 함수 혹은 메소드의 인자로 넘기는 중,
** !정의된 파라미터 타입에는 맞지 않을 때! 자동적으로 발생함. 
** 일련의 deref 메소드 호출은 우리가 제공한 타입을 파라미터가 요구하는 타입으로 변경해줌.
*/

//---------------------------------------------------------------------------------------------------------------------------

// 역참조 강제가 가변성과 상호작용 하는 법

// 불변 참조자에 대한 *를 오버라이딩하는 Deref 트레잇
// 가변 참조자에 대한 *를 오버라이딩하는 DerefMut 트레잇

// 역참조 강제를 수행하는 타입과 트레잇 구현
/*
** 1. T: Deref<Target=U> 일 때,    &T     에서 &U로       
** 2. T: DerefMut<Target=U> 일 때, &mut T 에서 &mut U 로
** 3. T: Deref<Target=U> 일 때,    &mut T 에서 &U 로
*/

// 설명
// 1번 예: &T를 가지고 있을 때, T가 어떤 타입 U에 대한 Deref를 구현 했다면, &U를 얻을 수 있음. (&String -> &str 예 처럼)
// 2번 예: 1번 예의 가변성 추가
// 3번 예: 소유권 규칙이 개입하는데, &mut 에서 &U로 가는 것은 가능하지만 역이 불가능 한 이유는 소유권
//         가변 참조자는 해당 데이터에 대한 !유일한 참조자!에 틀림 없음(가변 참조자가 2개 이상일 수는 없으니까!)
//         그래서, 유일한 것에서 불변 참조자로 가는 것은 가능함
//         근데 불변 참조자는 여러개가 존재할 수 있음.
//         불변참조자를 가변 참조자로 변경하는 것은. 해당 데이터에 대한 단! 하나의 불변 참조자가 있어야 한다는 요구를 받게되는데,
//         이는 빌림 규칙에서 보장될 수 없기에 컴파일러도 불가능 판단을 함!



fn main() {

    // *와 함께 포인터를 따라가서 값을 얻기
    // 보통의 참조자는 포인터 타입이며, 이는 다른 어딘가에 저장된 값을 가리키는 화살표로 생각하는 것임
    let x = 5;
    let y = &x;

    assert_eq!(5, x);
    assert_eq!(5, *y);  // 참조자를 따라가서, 가리키고 있는 값을 얻는 것 -> 역참조
    // assert_eq!(5, y);  y는 참조자인데, 숫자와 숫자에 대한 참조자를 비교하는 건 서로 다른타입이라 불가능!

    // Box<T>를 참조자처럼 사용하기
    let y = Box::new(x);  // y는 x를 가리키는 박스
    assert_eq!(5, *y);    // y를 역참조 (Box에 Deref가 구현되어 있기 때문!)

    // 나만의 스마트 포인터 정의하기

    struct MyBox<T>(T);         // 튜플 구조체 (T)

    impl<T> MyBox<T> {
        fn new(x: T) -> MyBox<T> {
            MyBox(x)
        }
    }
    use std::ops::Deref;        // Deref 트레잇이 없다면, 컴파일러는 오직 &참조자들만 역참조 가능!
    impl<T> Deref for MyBox<T> {
        type Target=T;          // Deref 트레잇이 사용할 연관 타입을 정의

        fn deref(&self) -> &T {
            &self.0             // (T)의 0번 인덱스 !참조! 값을 줌! (왜냐하면 역참조 해야하니까!)
        }
    }

    
    let x = 5;
    let y = MyBox::new(x);
    
    assert_eq!(5, x);
    assert_eq!(5, *y);
    

    // 역참조 강제
    fn hello(name: &str) {
        println!("Hello, {}!", name)
    }

    let m = MyBox::new(String::from("Rust"));  // deref 메소드가 구현되어있는 MyBox
    hello(&m);  // &m = MyBox<String>의 참조자, Deref가 구현되어 &MyBox<String>의 self.0 반환
                // self.0 = &String이 되었고, String에도 Deref가 구현되어 이를 통해 deref 호출, &str 변환
    // 만약 역참조 강제가 없었을 시...
    // hello(&(*m)[:])   & 참조 (*m) 스트링 값 [..] 전체 슬라이스

    // 따라서, 러스트는 해당 타입을 분석하여 파라미터 타입에 맞는 참조자를 얻기위해,
    // 필요한 수만큼의 Deref::deref 사용!
}
