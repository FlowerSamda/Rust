//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// 포인터: 메모리의 주소 값을 담고 있는 변수에 대한 일반적인 개념.
// -> 어떤 다른 데이터를 참조(가리킴)       in Rust, "&"

// 스마트 포인터: 포인터처럼 작동하지만, 추가적인 메타데이터와 능력들도 가지고 있는 데이터 구조
// -> 참조 카운팅(reference counting) 스마트 포인터 타입이 예시
// -> 소유자 수를 계속 추적, 더이상 소유자가 없으면 데이터를 정리(drop) -> 어떤 데이터에 대한 여러 소유자를 만들 수 있게 함.

// 참조자와 스마트 포인터간의 차이
// 참조자: 데이터를 오직 !빌리기만 함!
// 스마트 포인터: 그들이 가리키고 있는 데이터를 !소유!  ex) String, Vec<T>
// String, Vec<T> 가 스마트 포인터인 이유: 얼마간의 메모리 소유, 이를 다루도록 허용, 용량 등의 메타데이터 소유, String이 언제나 유효한 UTF-8일 것임을 보장하는 등의 추가능력 혹은 보장 소유

//-------------------------------------------------------------------------------------------------------------------------------------------

// 스마트 포인터는 보통 !구조체를 이용하여 구현!되어있으나, 일반적인 구조체와 구분되는 특성이 있음
// -> 스마트 포인터는 Deref와 Drop 트레잇을 구현한다는 것.

// Deref trait: 스마트 포인터 구조체의 인스턴스가 참조자처럼 동작하도록 하여, 참조자나 스마트 포인터 둘 중 하나와 함께 작동하는 코드를 작성하게 해줌.
// Drop trait: 스마트 포인터의 인스턴스가 스코프 밖으로 벗어났을 때 실행되는 코드를 커스터마이징 가능하도록 해줌.

/* 표준 라이브러리 내의 가장 흔한 스마트 포인터:
**
** 1. 값을 Heap에 할당하기 위한 Box<T>
** 2. 복수개의 소유권을 가능하게 하는 참조 카운팅 타입인 Rc<T>
** 3. 빌림 규칙을 컴파일 타임 대신 런타임에 강제하는 타입 RefCell<T>를 통해 접근 가능한 Ref<T>, RefMut<T>
*/

//-------------------------------------------------------------------------------------------------------------------------------------------

fn main() {
    println!("Hello, world!");
}
